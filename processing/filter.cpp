#include <iostream>
#include <vector>
#include <fstream>
#include "filter.h"
#include "../audio/sampling.h"
/*
  Refs:
  [1] http://www.earlevel.com/main/2003/02/28/biquads/
  [2] http://www.earlevel.com/main/2012/11/26/biquad-c-source-code/
  [3] https://ccrma.stanford.edu/~jos/fp/Transposed_Direct_Forms.html
  [4] Real Time Signal Processing by S. Kuo and B. Lee, Chapter 6 "Design and Implementation of IIR Filters"
  
  IIR filter is used, because our tuner requires harsh filter specifications:
  it should have cuttoff frequency around 82Hz (which is 0.0037 of Nyquist frequency) and
  large stopband attenuation (about 120dB). When those specifications were given to
  FIR filter designer it produced extremely high-order filter (about 400-500 coefs).
  And, since we don't need linear phase response, IIR is considered to be better choice.

  As for analog filter choice, I've chosen elliptic filter because we need narrowest
  possible transition region (from 50Hz to 82Hz).
  See [5] http://www.etc.tuiasi.ro/cin/Downloads/Filters/Filters.htm for filter comparison.

  Filter implementaion is cascade of biquad filters section. This is a very popular
  method, it's less sensitive to quantization of its coefficients. ([5])
  Coefficients are generated by python script filter.py, that uses
  scipy.signal.iirdesign
  See https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.iirdesign.html
  and https://www.dsprelated.com/showarticle/164.php
 */

/*
  Function process must be called sequently, because it uses temp registers z1, z2
 */

inline double biquad::process(double in) {
  /* 
     Transposed Form II is used because it's
     more suitable for float (see article above)
     z1 and z2 are "delay" temp registers
     (see diagram of Transposed Form II)
   */
  double out = in * b0 + z1;
  z1 = in * b1 + z2 - a1 * out; 
  z2 = in * b2 - a2 * out;
  return out;
}

void biquad::apply(amplitude_probes *amp) {
  /*
    Applies biquad section. Also creates and fills
    filtered vector. It is used because filtered signal has to be
    float number, but you can't put it into amplitudes, since
    it's int16_t or int8_t (possibly, won't fit).
    */
  int i;
  amp->filtered.reserve(amp->count);
  for (i = 0; i < amp->count; i++) {
    amp->filtered.push_back(process((double) (*amp)[i]));
  }
}
  
void biquad::apply(std::vector <double> x) {
  /*
    Applies biquad section.
    */
  int i;
  for (i = 0; i < x.size(); i++) {
    x[i] = process(x[i]);
  }
}

  
biquad::biquad(std::ifstream& file) {
  z1 = z2 = 0;
  file >> b0 >> b1 >> b2;
  file >> a0 >> a1 >> a2;
}


filter::filter(std::ifstream& file) {
  file >> k;
  cascades.reserve(k);
  for (int i = 0; i < k; i++) {
    cascades.push_back(biquad(file));
  }
}

void filter::apply(amplitude_probes* amp) {
  cascades[0].apply(amp);
  for (int i = 1; i < k; i++) {
    cascades[i].apply(amp->filtered);
  }
}


